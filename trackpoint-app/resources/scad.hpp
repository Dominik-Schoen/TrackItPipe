#pragma once
// AUTOGENERATED FILE - DO NOT EDIT
const char* threads_SCAD = "function segments (diameter) = min (50, max (ceil (diameter*6), 25));\n"
"module metric_thread (diameter=8, pitch=1, length=1, internal=false, n_starts=1,\n"
"thread_size=-1, groove=false, square=false, rectangle=0,\n"
"angle=30, taper=0, leadin=0, leadfac=1.0, test=false)\n"
"{\n"
"local_thread_size = thread_size == -1 ? pitch : thread_size;\n"
"local_rectangle = rectangle ? rectangle : 1;\n"
"n_segments = segments (diameter);\n"
"h = (test && ! internal) ? 0 : (square || rectangle) ? local_thread_size*local_rectangle/2 : local_thread_size / (2 * tan(angle));\n"
"h_fac1 = (square || rectangle) ? 0.90 : 0.625;\n"
"h_fac2 = (square || rectangle) ? 0.95 : 5.3/8;\n"
"tapered_diameter = diameter - length*taper;\n"
"difference () {\n"
"union () {\n"
"if (! groove) {\n"
"if (! test) {\n"
"metric_thread_turns (diameter, pitch, length, internal, n_starts,\n"
"local_thread_size, groove, square, rectangle, angle,\n"
"taper);\n"
"}\n"
"}\n"
"difference () {\n"
"if (groove) {\n"
"cylinder (r1=diameter/2, r2=tapered_diameter/2,\n"
"h=length, $fn=n_segments);\n"
"} else if (internal) {\n"
"cylinder (r1=diameter/2 - h*h_fac1, r2=tapered_diameter/2 - h*h_fac1,\n"
"h=length, $fn=n_segments);\n"
"} else {\n"
"cylinder (r1=diameter/2 - h*h_fac2, r2=tapered_diameter/2 - h*h_fac2,\n"
"h=length, $fn=n_segments);\n"
"}\n"
"if (groove) {\n"
"if (! test) {\n"
"metric_thread_turns (diameter, pitch, length, internal, n_starts,\n"
"local_thread_size, groove, square, rectangle,\n"
"angle, taper);\n"
"}\n"
"}\n"
"}\n"
"if (internal) {\n"
"if (leadin == 2 || leadin == 3) {\n"
"cylinder (r1=diameter/2, r2=diameter/2 - h*h_fac1*leadfac, h=h*h_fac1*leadfac,\n"
"$fn=n_segments);\n"
"}\n"
"if (leadin == 1 || leadin == 2) {\n"
"translate ([0, 0, length + 0.05 - h*h_fac1*leadfac]) {\n"
"cylinder (r1=tapered_diameter/2 - h*h_fac1*leadfac, h=h*h_fac1*leadfac,\n"
"r2=tapered_diameter/2,\n"
"$fn=n_segments);\n"
"}\n"
"}\n"
"}\n"
"}\n"
"if (! internal) {\n"
"if (leadin == 2 || leadin == 3) {\n"
"difference () {\n"
"cylinder (r=diameter/2 + 1, h=h*h_fac1*leadfac, $fn=n_segments);\n"
"cylinder (r2=diameter/2, r1=diameter/2 - h*h_fac1*leadfac, h=h*h_fac1*leadfac,\n"
"$fn=n_segments);\n"
"}\n"
"}\n"
"if (leadin == 1 || leadin == 2) {\n"
"translate ([0, 0, length + 0.05 - h*h_fac1*leadfac]) {\n"
"difference () {\n"
"cylinder (r=diameter/2 + 1, h=h*h_fac1*leadfac, $fn=n_segments);\n"
"cylinder (r1=tapered_diameter/2, r2=tapered_diameter/2 - h*h_fac1*leadfac, h=h*h_fac1*leadfac,\n"
"$fn=n_segments);\n"
"}\n"
"}\n"
"}\n"
"}\n"
"}\n"
"}\n"
"module english_thread (diameter=0.25, threads_per_inch=20, length=1,\n"
"internal=false, n_starts=1, thread_size=-1, groove=false,\n"
"square=false, rectangle=0, angle=30, taper=0, leadin=0,\n"
"leadfac=1.0, test=false)\n"
"{\n"
"mm_diameter = diameter*25.4;\n"
"mm_pitch = (1.0/threads_per_inch)*25.4;\n"
"mm_length = length*25.4;\n"
"echo (str (\"mm_diameter: \", mm_diameter));\n"
"echo (str (\"mm_pitch: \", mm_pitch));\n"
"echo (str (\"mm_length: \", mm_length));\n"
"metric_thread (mm_diameter, mm_pitch, mm_length, internal, n_starts,\n"
"thread_size, groove, square, rectangle, angle, taper, leadin,\n"
"leadfac, test);\n"
"}\n"
"module metric_thread_turns (diameter, pitch, length, internal, n_starts,\n"
"thread_size, groove, square, rectangle, angle,\n"
"taper)\n"
"{\n"
"n_turns = floor (length/pitch);\n"
"intersection () {\n"
"for (i=[-1*n_starts : n_turns+1]) {\n"
"translate ([0, 0, i*pitch]) {\n"
"metric_thread_turn (diameter, pitch, internal, n_starts,\n"
"thread_size, groove, square, rectangle, angle,\n"
"taper, i*pitch);\n"
"}\n"
"}\n"
"translate ([0, 0, length/2]) {\n"
"cube ([diameter*3, diameter*3, length], center=true);\n"
"}\n"
"}\n"
"}\n"
"module metric_thread_turn (diameter, pitch, internal, n_starts, thread_size,\n"
"groove, square, rectangle, angle, taper, z)\n"
"{\n"
"n_segments = segments (diameter);\n"
"fraction_circle = 1.0/n_segments;\n"
"for (i=[0 : n_segments-1]) {\n"
"rotate ([0, 0, i*360*fraction_circle]) {\n"
"translate ([0, 0, i*n_starts*pitch*fraction_circle]) {\n"
"thread_polyhedron ((diameter - taper*(z + i*n_starts*pitch*fraction_circle))/2,\n"
"pitch, internal, n_starts, thread_size, groove,\n"
"square, rectangle, angle);\n"
"}\n"
"}\n"
"}\n"
"}\n"
"module thread_polyhedron (radius, pitch, internal, n_starts, thread_size,\n"
"groove, square, rectangle, angle)\n"
"{\n"
"n_segments = segments (radius*2);\n"
"fraction_circle = 1.0/n_segments;\n"
"local_rectangle = rectangle ? rectangle : 1;\n"
"h = (square || rectangle) ? thread_size*local_rectangle/2 : thread_size / (2 * tan(angle));\n"
"outer_r = radius + (internal ? h/20 : 0); // Adds internal relief.\n"
"h_fac1 = (square || rectangle) ? 1.1 : 0.875;\n"
"inner_r = radius - h*h_fac1; // Does NOT do Dmin_truncation - do later with\n"
"translate_y = groove ? outer_r + inner_r : 0;\n"
"reflect_x   = groove ? 1 : 0;\n"
"x_incr_outer = (! groove ? outer_r : inner_r) * fraction_circle * 2 * PI * 1.02;\n"
"x_incr_inner = (! groove ? inner_r : outer_r) * fraction_circle * 2 * PI * 1.02;\n"
"z_incr = n_starts * pitch * fraction_circle * 1.005;\n"
"x1_outer = outer_r * fraction_circle * 2 * PI;\n"
"z0_outer = (outer_r - inner_r) * tan(angle);\n"
"z1_outer = z0_outer + z_incr;\n"
"bottom = internal ? 0.235 : 0.25;\n"
"top    = internal ? 0.765 : 0.75;\n"
"translate ([0, translate_y, 0]) {\n"
"mirror ([reflect_x, 0, 0]) {\n"
"if (square || rectangle) {\n"
"polyhedron (\n"
"points = [\n"
"[-x_incr_inner/2, -inner_r, bottom*thread_size],         // [0]\n"
"[x_incr_inner/2, -inner_r, bottom*thread_size + z_incr], // [1]\n"
"[x_incr_inner/2, -inner_r, top*thread_size + z_incr],    // [2]\n"
"[-x_incr_inner/2, -inner_r, top*thread_size],            // [3]\n"
"[-x_incr_outer/2, -outer_r, bottom*thread_size],         // [4]\n"
"[x_incr_outer/2, -outer_r, bottom*thread_size + z_incr], // [5]\n"
"[x_incr_outer/2, -outer_r, top*thread_size + z_incr],    // [6]\n"
"[-x_incr_outer/2, -outer_r, top*thread_size]             // [7]\n"
"],\n"
"faces = [\n"
"[0, 3, 7, 4],  // This-side trapezoid\n"
"[1, 5, 6, 2],  // Back-side trapezoid\n"
"[0, 1, 2, 3],  // Inner rectangle\n"
"[4, 7, 6, 5],  // Outer rectangle\n"
"[7, 2, 6],     // Upper rectangle, bottom\n"
"[7, 3, 2],     // Upper rectangle, top\n"
"[0, 5, 1],     // Lower rectangle, bottom\n"
"[0, 4, 5]      // Lower rectangle, top\n"
"]\n"
");\n"
"} else {\n"
"polyhedron (\n"
"points = [\n"
"[-x_incr_inner/2, -inner_r, 0],                        // [0]\n"
"[x_incr_inner/2, -inner_r, z_incr],                    // [1]\n"
"[x_incr_inner/2, -inner_r, thread_size + z_incr],      // [2]\n"
"[-x_incr_inner/2, -inner_r, thread_size],              // [3]\n"
"[-x_incr_outer/2, -outer_r, z0_outer],                 // [4]\n"
"[x_incr_outer/2, -outer_r, z0_outer + z_incr],         // [5]\n"
"[x_incr_outer/2, -outer_r, thread_size - z0_outer + z_incr], // [6]\n"
"[-x_incr_outer/2, -outer_r, thread_size - z0_outer]    // [7]\n"
"],\n"
"faces = [\n"
"[0, 3, 7, 4],  // This-side trapezoid\n"
"[1, 5, 6, 2],  // Back-side trapezoid\n"
"[0, 1, 2, 3],  // Inner rectangle\n"
"[4, 7, 6, 5],  // Outer rectangle\n"
"[7, 2, 6],     // Upper rectangle, bottom\n"
"[7, 3, 2],     // Upper rectangle, top\n"
"[0, 5, 1],     // Lower rectangle, bottom\n"
"[0, 4, 5]      // Lower rectangle, top\n"
"]\n"
");\n"
"}\n"
"}\n"
"}\n"
"}\n"
;